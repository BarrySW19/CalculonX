package nl.zoidberg.calculon.silverbars;

import java.math.BigDecimal;

public class OrderSummary {

    // Not needed in this demo, but useful if we want to put these in a Map at some point...
    private final Key key;

    private BigDecimal orderQuantity = BigDecimal.ZERO;

    public OrderSummary(Order.Type orderType, BigDecimal pricePerKg) {
        key = new Key(orderType, pricePerKg);
    }

    public OrderSummary(Order.Type orderType, BigDecimal pricePerKg, BigDecimal initialQuantity) {
        this(orderType, pricePerKg);
        orderQuantity = initialQuantity;
    }

    public OrderSummary(Order order) {
        this(order.getOrderType(), order.getPricePerKg(), order.getOrderQuantity());
    }

    public Key getKey() {
        return key;
    }

    public BigDecimal getOrderQuantity() {
        return orderQuantity;
    }

    /**
     * Merge two summaries together.
     *
     * @param os1 The 1st summary
     * @param os2 The 2nd summary
     * @return The values combined
     * @throws java.lang.IllegalArgumentException if the summaries mismatch on type or price.
     */
    public static OrderSummary combine(OrderSummary os1, OrderSummary os2) {
        if(os1.key.orderType != os2.key.orderType) {
            throw new IllegalArgumentException("Incompatible types");
        }

        if(os1.key.pricePerKg.compareTo(os2.key.pricePerKg) != 0) { // Compare ignoring BigDecimal precision
            throw new IllegalArgumentException("Incompatible prices");
        }

        return new OrderSummary(os1.key.orderType, os1.key.pricePerKg, os1.orderQuantity.add(os2.orderQuantity));
    }

    @Override
    public String toString() {
        return "OrderSummary{" +
                "key=" + key +
                ", orderQuantity=" + orderQuantity +
                '}';
    }

    public class Key {
        private final Order.Type orderType;
        private final BigDecimal pricePerKg;

        public Key(Order.Type orderType, BigDecimal pricePerKg) {
            this.orderType = orderType;
            this.pricePerKg = pricePerKg;
        }

        public Order.Type getOrderType() {
            return orderType;
        }

        public BigDecimal getPricePerKg() {
            return pricePerKg;
        }

        @Override
        public boolean equals(Object other) {
            if (this == other) {
                return true;
            }

            if (other == null || getClass() != other.getClass()) {
                return false;
            }

            Key key = (Key) other;

            return orderType == key.orderType && pricePerKg.equals(key.pricePerKg);
        }

        @Override
        public int hashCode() {
            int result = orderType.hashCode();
            result = 31 * result + pricePerKg.hashCode();
            return result;
        }

        @Override
        public String toString() {
            return "Key{" +
                    "orderType=" + orderType +
                    ", pricePerKg=" + pricePerKg +
                    '}';
        }
    }
}
